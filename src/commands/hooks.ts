/**
 * CLI command: overstory hooks install|uninstall|status
 *
 * Manages orchestrator hooks from .overstory/hooks.json.
 * For Claude mode, hooks are written to .claude/settings.local.json.
 * For Codex mode, this command is a safe no-op (Codex does not consume
 * Claude hook settings).
 *
 * This keeps the canonical hook configuration in .overstory/ while placing
 * a minimal copy in .claude/ only when the user explicitly opts in.
 * Running `overstory init` alone does NOT modify .claude/ — the user must
 * run `overstory hooks install` as a separate step.
 */

import { mkdir, unlink } from "node:fs/promises";
import { join } from "node:path";
import { resolveCliBase } from "../cli-base.ts";
import { loadConfig } from "../config.ts";
import { ValidationError } from "../errors.ts";
import type { CliBase } from "../types.ts";

const HOOKS_SOURCE_RELATIVE = ".overstory/hooks.json";
const CLAUDE_HOOKS_TARGET_RELATIVE = ".claude/settings.local.json";

interface HooksContext {
	cliBase: CliBase;
	projectRoot: string;
	sourcePath: string;
	targetPath: string | null;
}

function getHooksHelp(cliBase: CliBase): string {
	if (cliBase === "codex") {
		return `overstory hooks — Manage orchestrator hooks

Usage: overstory hooks <subcommand>

Subcommands:
  install                  Safe no-op in codex mode (Codex does not read Claude hooks)
  uninstall                Safe no-op in codex mode (Codex does not read Claude hooks)
  status                   Show hooks source and codex no-op status

Options:
  --force                  Ignored in codex mode
  --json                   Output as JSON
  --help, -h               Show this help

Hooks source: ${HOOKS_SOURCE_RELATIVE} (generated by overstory init)
Hooks target: n/a (cli.base=codex)`;
	}

	return `overstory hooks — Manage orchestrator hooks

Usage: overstory hooks <subcommand>

Subcommands:
  install                  Install orchestrator hooks to ${CLAUDE_HOOKS_TARGET_RELATIVE}
  uninstall                Remove orchestrator hooks from ${CLAUDE_HOOKS_TARGET_RELATIVE}
  status                   Check if hooks are installed

Options:
  --force                  Overwrite existing hooks in ${CLAUDE_HOOKS_TARGET_RELATIVE}
  --json                   Output as JSON
  --help, -h               Show this help

Hooks source: ${HOOKS_SOURCE_RELATIVE} (generated by overstory init)
Hooks target: ${CLAUDE_HOOKS_TARGET_RELATIVE} (read by Claude Code)`;
}

async function loadHooksContext(): Promise<HooksContext> {
	const cwd = process.cwd();
	const config = await loadConfig(cwd);
	const cliBase = resolveCliBase(config);
	const projectRoot = config.project.root;

	return {
		cliBase,
		projectRoot,
		sourcePath: join(projectRoot, ".overstory", "hooks.json"),
		targetPath: cliBase === "claude" ? join(projectRoot, ".claude", "settings.local.json") : null,
	};
}

function printCodexNoop(subcommand: "install" | "uninstall", sourceExists: boolean): void {
	process.stdout.write(
		`cli.base is "codex"; 'overstory hooks ${subcommand}' is a safe no-op (Codex does not read Claude hook settings).\n`,
	);
	process.stdout.write(
		`  Source (${HOOKS_SOURCE_RELATIVE}): ${sourceExists ? "present" : "missing"}\n`,
	);
}

/**
 * Install orchestrator hooks from .overstory/hooks.json to .claude/settings.local.json.
 *
 * Reads the canonical hook config from .overstory/hooks.json and writes it to
 * .claude/settings.local.json where Claude Code discovers it. Preserves any
 * existing non-hooks keys in the target file.
 */
async function installHooks(args: string[], context: HooksContext): Promise<void> {
	const force = args.includes("--force");
	const sourceFile = Bun.file(context.sourcePath);
	const sourceExists = await sourceFile.exists();

	if (context.cliBase !== "claude") {
		printCodexNoop("install", sourceExists);
		return;
	}

	if (!context.targetPath) {
		throw new ValidationError("Claude hooks target path was not resolved.", { field: "target" });
	}

	if (!sourceExists) {
		throw new ValidationError("No hooks.json found in .overstory/. Run 'overstory init' first.", {
			field: "source",
		});
	}

	const sourceContent = await sourceFile.text();
	const sourceHooks = JSON.parse(sourceContent) as Record<string, unknown>;

	// Check target .claude/settings.local.json
	const targetDir = join(context.projectRoot, ".claude");
	const targetFile = Bun.file(context.targetPath);

	let targetConfig: Record<string, unknown> = {};
	if (await targetFile.exists()) {
		const existingContent = await targetFile.text();
		const existing = JSON.parse(existingContent) as Record<string, unknown>;

		if (existing.hooks && !force) {
			process.stdout.write(
				`Hooks already present in ${CLAUDE_HOOKS_TARGET_RELATIVE}\nUse --force to overwrite.\n`,
			);
			return;
		}

		// Preserve non-hooks keys (e.g., env settings)
		targetConfig = existing;
	}

	// Merge: set hooks from source, preserve other keys
	targetConfig.hooks = sourceHooks.hooks;

	// Write
	await mkdir(targetDir, { recursive: true });
	await Bun.write(context.targetPath, `${JSON.stringify(targetConfig, null, "\t")}\n`);

	process.stdout.write(`\u2713 Installed orchestrator hooks to ${CLAUDE_HOOKS_TARGET_RELATIVE}\n`);
	process.stdout.write(`  Source: ${HOOKS_SOURCE_RELATIVE}\n`);
}

/**
 * Remove orchestrator hooks from .claude/settings.local.json.
 *
 * If hooks were the only content, removes the file entirely.
 * Otherwise, preserves other keys and only removes the hooks key.
 */
async function uninstallHooks(_args: string[], context: HooksContext): Promise<void> {
	const sourceExists = await Bun.file(context.sourcePath).exists();
	if (context.cliBase !== "claude") {
		printCodexNoop("uninstall", sourceExists);
		return;
	}

	if (!context.targetPath) {
		throw new ValidationError("Claude hooks target path was not resolved.", { field: "target" });
	}

	const targetFile = Bun.file(context.targetPath);

	if (!(await targetFile.exists())) {
		process.stdout.write(`No ${CLAUDE_HOOKS_TARGET_RELATIVE} found — nothing to uninstall.\n`);
		return;
	}

	const content = await targetFile.text();
	const parsed = JSON.parse(content) as Record<string, unknown>;

	if (!parsed.hooks) {
		process.stdout.write(
			`No hooks found in ${CLAUDE_HOOKS_TARGET_RELATIVE} — nothing to uninstall.\n`,
		);
		return;
	}

	// Separate hooks from other settings
	const { hooks: _hooks, ...rest } = parsed;

	const remainingKeys = Object.keys(rest);
	if (remainingKeys.length === 0) {
		await unlink(context.targetPath);
		process.stdout.write(`\u2713 Removed ${CLAUDE_HOOKS_TARGET_RELATIVE} (was hooks-only)\n`);
	} else {
		await Bun.write(context.targetPath, `${JSON.stringify(rest, null, "\t")}\n`);
		process.stdout.write(
			`\u2713 Removed hooks from ${CLAUDE_HOOKS_TARGET_RELATIVE} (preserved other settings)\n`,
		);
	}
}

/**
 * Show hooks installation status.
 */
async function statusHooks(args: string[], context: HooksContext): Promise<void> {
	const json = args.includes("--json");
	const sourceExists = await Bun.file(context.sourcePath).exists();

	if (context.cliBase !== "claude") {
		if (json) {
			process.stdout.write(
				`${JSON.stringify({
					sourceExists,
					installed: false,
					cliBase: context.cliBase,
					managed: false,
				})}\n`,
			);
			return;
		}

		process.stdout.write(
			`Hooks source (${HOOKS_SOURCE_RELATIVE}): ${sourceExists ? "present" : "missing"}\n`,
		);
		process.stdout.write("Hooks target: n/a (cli.base=codex)\n");
		process.stdout.write("Hooks installed: n/a (codex mode is a safe no-op)\n");
		return;
	}

	if (!context.targetPath) {
		throw new ValidationError("Claude hooks target path was not resolved.", { field: "target" });
	}

	const targetExists = await Bun.file(context.targetPath).exists();

	let installed = false;
	if (targetExists) {
		const content = await Bun.file(context.targetPath).text();
		const parsed = JSON.parse(content) as Record<string, unknown>;
		installed = !!parsed.hooks;
	}

	if (json) {
		process.stdout.write(`${JSON.stringify({ sourceExists, installed })}\n`);
	} else {
		process.stdout.write(
			`Hooks source (${HOOKS_SOURCE_RELATIVE}): ${sourceExists ? "present" : "missing"}\n`,
		);
		process.stdout.write(
			`Hooks installed (${CLAUDE_HOOKS_TARGET_RELATIVE}): ${installed ? "yes" : "no"}\n`,
		);
		if (!installed && sourceExists) {
			process.stdout.write(`\nRun 'overstory hooks install' to install.\n`);
		}
	}
}

/**
 * Entry point for `overstory hooks <subcommand>`.
 */
export async function hooksCommand(args: string[]): Promise<void> {
	if (args.includes("--help") || args.includes("-h") || args.length === 0) {
		let cliBase: CliBase = "claude";
		try {
			const context = await loadHooksContext();
			cliBase = context.cliBase;
		} catch {
			// Preserve help usability when not in an initialized overstory repo.
		}
		process.stdout.write(`${getHooksHelp(cliBase)}\n`);
		return;
	}

	const subcommand = args[0];
	const subArgs = args.slice(1);

	if (subcommand !== "install" && subcommand !== "uninstall" && subcommand !== "status") {
		throw new ValidationError(
			`Unknown hooks subcommand: ${subcommand}. Run 'overstory hooks --help' for usage.`,
			{ field: "subcommand", value: subcommand },
		);
	}

	const context = await loadHooksContext();

	switch (subcommand) {
		case "install":
			await installHooks(subArgs, context);
			break;
		case "uninstall":
			await uninstallHooks(subArgs, context);
			break;
		case "status":
			await statusHooks(subArgs, context);
			break;
	}
}
